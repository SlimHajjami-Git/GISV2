-- ============================================================================
-- GPS Positions Table Partitioning Script
-- Partitioning by recorded_at (monthly partitions)
-- ============================================================================
-- 
-- IMPORTANT: This script should be run manually by a DBA.
-- It will:
-- 1. Create a new partitioned table
-- 2. Migrate existing data
-- 3. Rename tables to swap them
-- 4. Create partitions for the next 12 months
-- 5. Set up automatic partition creation
--
-- Prerequisites:
-- - PostgreSQL 11+ (native partitioning)
-- - Sufficient disk space for data migration
-- - Maintenance window (table will be briefly unavailable)
-- ============================================================================

-- Step 1: Create the partitioned table structure
CREATE TABLE IF NOT EXISTS gps_positions_partitioned (
    id bigint GENERATED BY DEFAULT AS IDENTITY,
    device_id integer NOT NULL,
    recorded_at timestamp with time zone NOT NULL,
    latitude double precision NOT NULL,
    longitude double precision NOT NULL,
    speed_kph double precision,
    course_deg double precision,
    altitude_m double precision,
    ignition_on boolean,
    fuel_raw integer,
    power_voltage integer,
    satellites integer,
    is_valid boolean NOT NULL DEFAULT true,
    is_real_time boolean NOT NULL DEFAULT true,
    metadata jsonb,
    created_at timestamp with time zone NOT NULL DEFAULT NOW(),
    -- New AAP columns
    "MemsX" smallint,
    "MemsY" smallint,
    "MemsZ" smallint,
    "TemperatureC" smallint,
    "OdometerKm" bigint,
    "Rpm" smallint,
    "SendFlag" smallint,
    "ProtocolVersion" smallint,
    "FuelRateLPer100Km" numeric(6,2),
    PRIMARY KEY (id, recorded_at)
) PARTITION BY RANGE (recorded_at);

-- Step 2: Create indexes on the partitioned table
CREATE INDEX IF NOT EXISTS ix_gps_positions_part_device_time 
    ON gps_positions_partitioned (device_id, recorded_at);

CREATE INDEX IF NOT EXISTS ix_gps_positions_part_time 
    ON gps_positions_partitioned (recorded_at);

-- Step 3: Create function to automatically create monthly partitions
CREATE OR REPLACE FUNCTION create_gps_positions_partition(partition_date DATE)
RETURNS void AS $$
DECLARE
    partition_name TEXT;
    start_date DATE;
    end_date DATE;
BEGIN
    start_date := date_trunc('month', partition_date);
    end_date := start_date + INTERVAL '1 month';
    partition_name := 'gps_positions_' || to_char(start_date, 'YYYY_MM');
    
    -- Check if partition already exists
    IF NOT EXISTS (
        SELECT 1 FROM pg_class c
        JOIN pg_namespace n ON n.oid = c.relnamespace
        WHERE c.relname = partition_name
        AND n.nspname = 'public'
    ) THEN
        EXECUTE format(
            'CREATE TABLE %I PARTITION OF gps_positions_partitioned
             FOR VALUES FROM (%L) TO (%L)',
            partition_name, start_date, end_date
        );
        RAISE NOTICE 'Created partition: %', partition_name;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Step 4: Create partitions for historical data and future months
-- Adjust the date range based on your existing data
DO $$
DECLARE
    start_month DATE := '2024-01-01';  -- Adjust to your earliest data
    end_month DATE := (date_trunc('month', CURRENT_DATE) + INTERVAL '12 months')::DATE;
    current_month DATE;
BEGIN
    current_month := start_month;
    WHILE current_month < end_month LOOP
        PERFORM create_gps_positions_partition(current_month);
        current_month := current_month + INTERVAL '1 month';
    END LOOP;
END $$;

-- Step 5: Migrate data from old table to partitioned table
-- WARNING: This can take a long time for large tables!
-- Consider doing this in batches during off-peak hours.

-- Option A: Full migration (for smaller datasets)
-- INSERT INTO gps_positions_partitioned 
-- SELECT * FROM gps_positions;

-- Option B: Batch migration (for larger datasets)
-- Run this in a loop or script:
/*
DO $$
DECLARE
    batch_size INT := 100000;
    offset_val INT := 0;
    rows_inserted INT;
BEGIN
    LOOP
        INSERT INTO gps_positions_partitioned
        SELECT * FROM gps_positions
        ORDER BY id
        LIMIT batch_size
        OFFSET offset_val;
        
        GET DIAGNOSTICS rows_inserted = ROW_COUNT;
        EXIT WHEN rows_inserted = 0;
        
        offset_val := offset_val + batch_size;
        RAISE NOTICE 'Migrated % rows (total: %)', rows_inserted, offset_val;
        
        -- Optional: Add a small delay to reduce load
        PERFORM pg_sleep(0.1);
    END LOOP;
END $$;
*/

-- Step 6: Swap tables (requires brief downtime)
-- Run these commands in a transaction during maintenance window:
/*
BEGIN;
    -- Rename old table
    ALTER TABLE gps_positions RENAME TO gps_positions_old;
    
    -- Rename partitioned table to original name
    ALTER TABLE gps_positions_partitioned RENAME TO gps_positions;
    
    -- Update foreign key constraints if any
    -- ALTER TABLE gps_alerts DROP CONSTRAINT IF EXISTS fk_gps_alerts_position;
    -- ALTER TABLE gps_alerts ADD CONSTRAINT fk_gps_alerts_position 
    --     FOREIGN KEY (position_id) REFERENCES gps_positions(id);
COMMIT;
*/

-- Step 7: Create a scheduled job to create future partitions
-- This can be done with pg_cron or a cron job running this SQL:
/*
-- Run monthly to create partition for 2 months ahead
SELECT create_gps_positions_partition(
    (date_trunc('month', CURRENT_DATE) + INTERVAL '2 months')::DATE
);
*/

-- Step 8: Optional - Drop old table after verification
-- DROP TABLE gps_positions_old;

-- ============================================================================
-- Maintenance Queries
-- ============================================================================

-- List all partitions
-- SELECT 
--     parent.relname AS parent_table,
--     child.relname AS partition_name,
--     pg_size_pretty(pg_relation_size(child.oid)) AS size
-- FROM pg_inherits
-- JOIN pg_class parent ON pg_inherits.inhparent = parent.oid
-- JOIN pg_class child ON pg_inherits.inhrelid = child.oid
-- WHERE parent.relname = 'gps_positions'
-- ORDER BY child.relname;

-- Check partition boundaries
-- SELECT 
--     pt.relname AS partition_name,
--     pg_get_expr(pt.relpartbound, pt.oid) AS partition_expression
-- FROM pg_class base_tb
-- JOIN pg_inherits i ON i.inhparent = base_tb.oid
-- JOIN pg_class pt ON pt.oid = i.inhrelid
-- WHERE base_tb.relname = 'gps_positions';

-- Drop old partitions (data retention)
-- DROP TABLE gps_positions_2023_01;  -- Example: drop January 2023 partition
